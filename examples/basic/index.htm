<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>-->
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <!--<script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>-->
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://code.jquery.com/pep/0.4.2/pep.js"></script>
        <script src="EditControl.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                user-select:none;
            }
            a {
              color: white;
            }
            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #canvasZone {
                width: 100%;
                height: 100%;
            }
            #box {
              position:absolute;
              bottom:0;
              left:0;
              width:300px;
              height:256px;
              overflow:scroll;
            }
            input[type=range] {
              width:128px;
              height:1em;
            }
            label {
              font-family:monospace;
            }
            #x {
                font-family:monospace;
                font-weight:bold;
                position:fixed;
                line-height:20px;
                font-size:16px;
                right:20px;
                top:0;
            }
        </style>
    </head>
<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
        var canvas = document.getElementById("renderCanvas");
        var then = new Date().getTime();
        var now, delta;
        const interval = 1000 / 25;
        const tolerance = 0.1;

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                now = new Date().getTime();
                delta = now - then;
                then = now - (delta % interval);
                if (delta >= interval - tolerance && sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var pipeline = null;
        var editControl = null;
        
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}, true); }; //adapt to device ratio
        class Playground {
            static CreateScene(engine, canvas) {
                // This creates a basic Babylon Scene object (non-mesh)
                var scene = new BABYLON.Scene(engine);
                var camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 2, 0, new BABYLON.Vector3(0, 0, 0));
                // This attaches the camera to the canvas
                camera.attachControl(canvas, true);
                //camera.inputs.attached.mousewheel.detachControl(canvas);
                
                if (location.href.split("?file=")[1]) {
                    var path = location.href.split("?file=")[1];
                    var fln = path.slice(path.lastIndexOf("/")+1);
                    var url = "https://freealise-depth-anything-video.hf.space/file=" + path.slice(0, path.lastIndexOf("/")+1); 
                } else {
                    var fln = "TriangleWithoutIndices.gltf";
                    var url = "https://huggingface.co/spaces/freealise/Depth-Anything-Video/resolve/main/"; 
                }
try {
BABYLON.SceneLoader.Append(url, fln, scene, function (scene) {
  engine.setHardwareScalingLevel(1.0);
  var bg = JSON.parse(document.getElementById("bgcolor").value);
  for (var i=0; i<bg.length; i++) {
    bg[i] /= 255;
  }
  scene.clearColor = new BABYLON.Color4(bg[0], bg[1], bg[2], bg[3]);
  //scene.autoClear = false;
  //scene.autoClearDepthAndStencil = false;
  scene.getAnimationRatio();

  var order = document.getElementById("order").value.split(",");
  var coords = JSON.parse(document.getElementById("coords").value);

  var bgi = document.getElementById("bgimage").value.slice(0,-1).split(",");
  var bgd = document.getElementById("bgdepth").value.slice(0,-1).split(",");
  document.getElementById("fnum").max = bgi.length-1;
  var dome = [];
  for (var j=0; j<bgi.length; j++) {
    dome[j] = new BABYLON.PhotoDome("dome"+j, bgi[j], 
      {
        resolution: 16,
        size: 512
      }, scene);
    var q = scene.meshes[scene.meshes.length-2]._children;
    for (i = 0; i < q.length; i++) {
      let mesh = q[i];
      mesh.dispose(false, true);
    }
    scene.meshes[scene.meshes.length-1].applyDisplacementMap(bgd[j], 0, 255, null, null, null, true, function(e){alert(e);});
    scene.meshes[scene.meshes.length-1].name = "dome"+j;
    //material.forceDepthWrite
    scene.meshes[scene.meshes.length-1].material.needDepthPrePass = true;
    scene.meshes[scene.meshes.length-1].alphaIndex = bgi.length-j;
    scene.meshes[scene.meshes.length-1].material.diffuseTexture.hasAlpha = true;
    scene.meshes[scene.meshes.length-1].material.useAlphaFromDiffuseTexture = true;
  }
  
  var j=0;
  for (var i=0; i<scene.getNodes().length; i++) {
    if (scene.getNodes()[i].name.indexOf("dome") == 0) {
      if (j==0) {
        document.getElementById("fnum").innerHTML = '<option selected value="' + i + '">' + i + '</option>';
        document.getElementById("fnum").value = i;
      } else {
        document.getElementById("fnum").innerHTML += '<option value="' + i + '">' + i + '</option>';
      }
      scene.getNodes()[i].rotationQuaternion = null;
      scene.getNodes()[i].material.pointSize = Math.ceil(Math.sqrt(2)*Math.log2(Math.PI/document.getElementById("zoom").value));
      scene.getNodes()[i].position.z = coords[parseInt(order[j])].lat;
      scene.getNodes()[i].position.x = coords[parseInt(order[j])].lng;
      scene.getNodes()[i].rotation.y = coords[parseInt(order[j])].heading / 180 * Math.PI;
      scene.getNodes()[i].rotation.z = -coords[parseInt(order[j])].pitch / 180 * Math.PI;
      j++;
    }
  }
  var l_axes = new BABYLON.Debug.AxesViewer(scene, 16);
  l_axes.xAxis.parent = scene.getNodes()[parseInt(document.getElementById("fnum").value)];
  l_axes.yAxis.parent = scene.getNodes()[parseInt(document.getElementById("fnum").value)];
  l_axes.zAxis.parent = scene.getNodes()[parseInt(document.getElementById("fnum").value)];
  
  var axes = new BABYLON.Debug.AxesViewer(scene, 32);
  var CoT = new BABYLON.TransformNode("root");
  CoT.rotationQuaternion = null;
  axes.parent = CoT;

  editControl = new EditControl(scene.getNodes()[parseInt(document.getElementById("fnum").value)], camera, canvas, 2.0, true, 0.02);
  editControl.enableTranslation();
  editControl.setTransSnapValue(1.0);

  pipeline = new BABYLON.DefaultRenderingPipeline("default", true, BABYLON.Engine.LastCreatedScene, [BABYLON.Engine.LastCreatedScene.activeCamera]);
  pipeline.samples = 4;
  pipeline.imageProcessing.contrast = document.getElementById("contrast").value;
  pipeline.imageProcessing.exposure = document.getElementById("exposure").value;

  BABYLON.Engine.LastCreatedScene.activeCamera.fov = document.getElementById("zoom").value;
  
  document.getElementById("renderCanvas").style.filter = "blur(" + BABYLON.Engine.LastCreatedScene.getNodes()[parseInt(document.getElementById("fnum").value)].material.pointSize/2.0 + "px)";
  document.getElementById("renderCanvas").oncontextmenu = function(e){e.preventDefault();}
  document.getElementById("renderCanvas").ondrag = function(e){e.preventDefault();}

});
} catch(e) {alert(e);}
                return scene;
            }
        }
        createScene = function() { return Playground.CreateScene(engine, engine.getRenderingCanvas()); }
                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene                    
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
<div id='box'>
<div><label for='zoom'>Zoom &nbsp; &nbsp;</label><input id='zoom' type='range' value='0.8' min='0.157' max='1.57' step='0.001'/><span>0.8</span></div>
<div><label for='exposure'>Exposure</label><input id='exposure' type='range' value='1.0' min='0' max='2' step='0.001'/><span>1.0</span></div>
<div><label for='contrast'>Contrast</label><input id='contrast' type='range' value='1.0' min='0' max='2' step='0.001'/><span>1.0</span></div>

<input type='text' id='coords' value='[{"lat":0.0, "lng":0.0, "heading":0.0, "pitch":0.0}]'/>
<input type='text' id='order' value='0'/>
<input type='text' id='bgcolor' value='[127, 127, 127, 255]'/>
<input type='text' id='bgimage' value='https://huggingface.co/spaces/freealise/Depth-Anything-Video/resolve/main/f0.jpg,'/>
<input type='text' id='bgdepth' value='https://huggingface.co/spaces/freealise/Depth-Anything-Video/resolve/main/f0_dmap.jpg,'/><br/>
# <select id='fnum' oninput='attach_control();' onselect='attach_control();'><option selected value='0'>0</option></select>
<a href='#' id='reset_cam' onclick='reset_cam();'>reset camera</a>
<a href='#' id='optimize' onclick='optimize();'>optimize</a><br/>

<a href='#' onclick='if(!scene.debugLayer.isVisible()){scene.debugLayer.show();}else{scene.debugLayer.hide();}'>inspector</a>
<a href='#' onclick='record_video();'>record</a>
<a href='#' onclick='snapshot();'>snapshot</a><br/>
<img src='' id='img_out' onload='var ctxt = document.getElementById("cnv_out").getContext("2d");ctxt.drawImage(this, 0, 0);'/><br/>
<canvas id='cnv_out'/>
</div>
<a href='#' id="x" onclick='if(document.getElementById("box").style.display!="none"){document.getElementById("box").style.display="none";}else{document.getElementById("box").style.display="block";}'>[x]</a><br/>
<script>

var screenshot = false;

document.getElementById('zoom').addEventListener('input', function(event){
try {
    for (var i=0; i<BABYLON.Engine.LastCreatedScene.getNodes().length; i++) {
        if (BABYLON.Engine.LastCreatedScene.getNodes()[i].material && BABYLON.Engine.LastCreatedScene.getNodes()[i].material.pointSize) {
              BABYLON.Engine.LastCreatedScene.getNodes()[i].material.pointSize = Math.ceil(Math.sqrt(2)*Math.log2(Math.PI/event.target.value));
        }
    }
    BABYLON.Engine.LastCreatedScene.activeCamera.fov = event.target.value;
    event.target.parentNode.childNodes[2].innerText = BABYLON.Engine.LastCreatedScene.activeCamera.fov;
    document.getElementById("renderCanvas").style.filter = "blur(" + Math.ceil(Math.sqrt(2)*Math.log2(Math.PI/event.target.value)/2.0) + "px)";
} catch(e) {alert(e)}
});

document.getElementById('exposure').addEventListener('input', function(event) {
    pipeline.imageProcessing.exposure = event.target.value;
    event.target.parentNode.childNodes[2].innerText = pipeline.imageProcessing.exposure;
});

document.getElementById('contrast').addEventListener('input', function(event) {
    pipeline.imageProcessing.contrast = event.target.value;
    event.target.parentNode.childNodes[2].innerText = pipeline.imageProcessing.contrast;
});


function attach_control() {
try {
  editControl.switchTo(scene.getNodes([parseInt(document.getElementById("fnum").value)], true);
} catch(e) {alert(e);}
}


function reset_cam() {
    BABYLON.Engine.LastCreatedScene.activeCamera.radius = 0;
    BABYLON.Engine.LastCreatedScene.activeCamera.alpha = 0;
    BABYLON.Engine.LastCreatedScene.activeCamera.beta = Math.PI / 2;
    BABYLON.Engine.LastCreatedScene.activeCamera.position.x = BABYLON.Engine.LastCreatedScene.getNodes()[parseInt(document.getElementById("fnum").value)].position.x;
    BABYLON.Engine.LastCreatedScene.activeCamera.position.y = BABYLON.Engine.LastCreatedScene.getNodes()[parseInt(document.getElementById("fnum").value)].position.y;
    BABYLON.Engine.LastCreatedScene.activeCamera.position.z = BABYLON.Engine.LastCreatedScene.getNodes()[parseInt(document.getElementById("fnum").value)].position.z;
    BABYLON.Engine.LastCreatedScene.activeCamera.rebuildAnglesAndRadius();
}


function optimize() {
  var options = new BABYLON.SceneOptimizerOptions(25);
  var optimizer = new BABYLON.SceneOptimizer(scene, options);
  optimizer.onSuccessObservable.add(function() {
    alert('ok');
  });
  optimizer.onNewOptimizationAppliedObservable.add(function (optim) {
    alert(optim.getDescription());
  });
  optimizer.onFailureObservable.add(function() {
    alert('slow');
  });
  optimizer.start();
}


function snapshot() {
    screenshot = true;
BABYLON.Engine.LastCreatedScene.getEngine().onEndFrameObservable.add(function() {
    if (screenshot === true) {
    screenshot = false;
    try {
BABYLON.Tools.CreateScreenshotUsingRenderTarget(BABYLON.Engine.LastCreatedScene.getEngine(), BABYLON.Engine.LastCreatedScene.activeCamera, 
        { precision: 1.0 }, (durl) => { 
             var cnvs = document.getElementById("renderCanvas"); //.getContext("webgl2");
             var svgd = `<svg id="svg_out" viewBox="0 0 ` + cnvs.width + ` ` + cnvs.height + `" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <defs>
                            <filter id="blur" x="0" y="0" xmlns="http://www.w3.org/2000/svg">
                              <feGaussianBlur in="SourceGraphic" stdDeviation="` + BABYLON.Engine.LastCreatedScene.getNodes()[parseInt(document.getElementById('fnum').value)].material.pointSize/2.0*Math.sqrt(2.0) + `" />
                            </filter>
                          </defs>
                          <image filter="url(#blur)" id="svg_img" x="0" y="0" width="` + cnvs.width + `" height="` + cnvs.height + `" xlink:href=\"` + durl + `\"/>
                        </svg>`;
                        document.getElementById("cnv_out").width = cnvs.width;
                        document.getElementById("cnv_out").height = cnvs.height;
                        document.getElementById("img_out").src = "data:image/svg+xml;base64," + btoa(svgd);        
                      }
                    );
                  } catch(e) { alert(e); }
                  // https://forum.babylonjs.com/t/best-way-to-save-to-jpeg-snapshots-of-scene/17663/11
                }
          });
}


function record_video() {
  if (BABYLON.VideoRecorder.IsSupported(engine)) {
    var recorder = new BABYLON.VideoRecorder(engine, { mimeType:'video/mp4', fps:25 });
    recorder.startRecording('video.mp4');
  }
}
            
</script>
</body>
</html>